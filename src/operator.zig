const SmallString = @import("string.zig").Small;

const std = @import("std");

pub const Operator = enum {
    op_none,
    op_return,
    op_new_generic,
    op_increment,
    op_decrement,
    op_assign,
    op_equals,
    op_less_than,
    op_less_equal,
    op_greater_than,
    op_greater_equal,
    op_plus,
    op_plus_assign,
    op_minus,
    op_minus_assign,
    op_multiply,
    op_multiply_assign,
    op_exponentiate1,
    op_exponentiate1_assign,
    op_exponentiate,
    op_exponentiate_assign,
    op_divide,
    op_divide_assign,
    op_integer_divide,
    op_integer_divide_assign,
    op_modulus,
    op_modulus_assign,
    op_remainder,
    op_remainder_assign,
    op_nullify,
    op_nullish_or,
    op_nullish_or_assign,
    op_not,
    op_not_not,
    op_not_equal,
    op_declare_generic,
    op_declare_readonly,
    op_declare_writable,
    op_declare_temporary,
    op_comma,
    op_logical_and,
    op_logical_and_assign,
    op_logical_or,
    op_logical_or_assign,
    op_bitwise_and,
    op_bitwise_and_assign,
    op_bitwise_or,
    op_bitwise_or_assign,
    op_bitwise_xor,
    op_bitwise_xor_assign,
    op_bitwise_flip,
    op_bitshift_left,
    op_bitshift_left_assign,
    op_bitshift_right,
    op_bitshift_right_assign,
    op_lambda1,
    op_lambda2,
    op_lambda3,
    op_lambda4,
    op_lambda5,
    op_lambda6,
    op_lambda7,
    op_lambda8,
    op_indent,
    op_access,
    op_readonly_member_access,
    op_writable_member_access,
    op_temporary_member_access,
    op_wr_member_access,
    op_rw_member_access,
    op_wt_member_access,
    op_tw_member_access,
    op_rt_member_access,
    op_tr_member_access,
    op_rwt_member_access,
    op_wrt_member_access,
    op_rtw_member_access,
    op_wtr_member_access,
    op_trw_member_access,
    op_twr_member_access,

    /// Returns 0 if `buffer` is an invalid operator, otherwise
    /// the numerical value of the operator (see `SmallString.as64`).
    pub fn init(buffer: []const u8) Self {
        if (buffer.len > 8) {
            return .op_none;
        }
        const small = SmallString.init(buffer) catch unreachable;
        const value64 = small.big64() catch unreachable;
        return init64(value64);
    }

    pub fn init64(value: u64) Self {
        return switch (value) {
            SmallString.as64("return") => .op_return,
            SmallString.as64("~") => .op_new_generic,
            SmallString.as64("++") => .op_increment,
            SmallString.as64("--") => .op_decrement,
            SmallString.as64("=") => .op_assign,
            SmallString.as64("==") => .op_equals,
            SmallString.as64("<") => .op_less_than,
            SmallString.as64("<=") => .op_less_equal,
            SmallString.as64(">") => .op_greater_than,
            SmallString.as64(">=") => .op_greater_equal,
            SmallString.as64("+") => .op_plus,
            SmallString.as64("+=") => .op_plus_assign,
            SmallString.as64("-") => .op_minus,
            SmallString.as64("-=") => .op_minus_assign,
            SmallString.as64("*") => .op_multiply,
            SmallString.as64("*=") => .op_multiply_assign,
            SmallString.as64("**") => .op_exponentiate1,
            SmallString.as64("**=") => .op_exponentiate1_assign,
            SmallString.as64("^") => .op_exponentiate,
            SmallString.as64("^=") => .op_exponentiate_assign,
            SmallString.as64("/") => .op_divide,
            SmallString.as64("/=") => .op_divide_assign,
            SmallString.as64("//") => .op_integer_divide,
            SmallString.as64("//=") => .op_integer_divide_assign,
            SmallString.as64("%") => .op_modulus,
            SmallString.as64("%=") => .op_modulus_assign,
            SmallString.as64("%%") => .op_remainder,
            SmallString.as64("%%=") => .op_remainder_assign,
            SmallString.as64("?") => .op_nullify,
            SmallString.as64("??") => .op_nullish_or,
            SmallString.as64("??=") => .op_nullish_or_assign,
            SmallString.as64("!") => .op_not,
            SmallString.as64("!!") => .op_not_not,
            SmallString.as64("!=") => .op_not_equal,
            SmallString.as64("`") => .op_declare_generic,
            SmallString.as64(":") => .op_declare_readonly,
            SmallString.as64(";") => .op_declare_writable,
            SmallString.as64(".") => .op_declare_temporary,
            SmallString.as64(",") => .op_comma,
            SmallString.as64("&&") => .op_logical_and,
            SmallString.as64("&&=") => .op_logical_and_assign,
            SmallString.as64("||") => .op_logical_or,
            SmallString.as64("||=") => .op_logical_or_assign,
            SmallString.as64("&") => .op_bitwise_and,
            SmallString.as64("&=") => .op_bitwise_and_assign,
            SmallString.as64("|") => .op_bitwise_or,
            SmallString.as64("|=") => .op_bitwise_or_assign,
            SmallString.as64("><") => .op_bitwise_xor,
            SmallString.as64("><=") => .op_bitwise_xor_assign,
            SmallString.as64("<>") => .op_bitwise_flip,
            SmallString.as64("<<") => .op_bitshift_left,
            SmallString.as64("<<=") => .op_bitshift_left_assign,
            SmallString.as64(">>") => .op_bitshift_right,
            SmallString.as64(">>=") => .op_bitshift_right_assign,
            SmallString.as64("$") => .op_lambda1,
            SmallString.as64("$$") => .op_lambda2,
            SmallString.as64("$$$") => .op_lambda3,
            SmallString.as64("$$$$") => .op_lambda4,
            SmallString.as64("$$$$$") => .op_lambda5,
            SmallString.as64("$$$$$$") => .op_lambda6,
            SmallString.as64("$$$$$$$") => .op_lambda7,
            SmallString.as64("$$$$$$$$") => .op_lambda8,
            SmallString.as64("\t") => .op_indent,
            SmallString.as64(" ") => .op_access,
            SmallString.as64("::") => .op_readonly_member_access,
            SmallString.as64(";;") => .op_writable_member_access,
            SmallString.as64("..") => .op_temporary_member_access,
            SmallString.as64(";:") => .op_wr_member_access,
            SmallString.as64(":;") => .op_rw_member_access,
            SmallString.as64(";.") => .op_wt_member_access,
            SmallString.as64(".;") => .op_tw_member_access,
            SmallString.as64(":.") => .op_rt_member_access,
            SmallString.as64(".:") => .op_tr_member_access,
            SmallString.as64(":;.") => .op_rwt_member_access,
            SmallString.as64(";:.") => .op_wrt_member_access,
            SmallString.as64(":.;") => .op_rtw_member_access,
            SmallString.as64(";.:") => .op_wtr_member_access,
            SmallString.as64(".:;") => .op_trw_member_access,
            SmallString.as64(".;:") => .op_twr_member_access,
            // We also convert some unnecessarily verbose operators.
            SmallString.as64(":=") => .op_declare_readonly,
            SmallString.as64(";=") => .op_declare_writable,
            else => .op_none,
        };
    }

    pub fn printLine(self: Self, writer: anytype) !void {
        try self.print(writer);
        try writer.print("\n", .{});
    }

    pub fn print(self: Self, writer: anytype) !void {
        return try switch (self) {
            .op_none => writer.print("op_none", .{}),
            .op_return => writer.print("op_return", .{}),
            .op_new_generic => writer.print("op_new_generic", .{}),
            .op_increment => writer.print("op_increment", .{}),
            .op_decrement => writer.print("op_decrement", .{}),
            .op_assign => writer.print("op_assign", .{}),
            .op_equals => writer.print("op_equals", .{}),
            .op_less_than => writer.print("op_less_than", .{}),
            .op_less_equal => writer.print("op_less_equal", .{}),
            .op_greater_than => writer.print("op_greater_than", .{}),
            .op_greater_equal => writer.print("op_greater_equal", .{}),
            .op_plus => writer.print("op_plus", .{}),
            .op_plus_assign => writer.print("op_plus_assign", .{}),
            .op_minus => writer.print("op_minus", .{}),
            .op_minus_assign => writer.print("op_minus_assign", .{}),
            .op_multiply => writer.print("op_multiply", .{}),
            .op_multiply_assign => writer.print("op_multiply_assign", .{}),
            .op_exponentiate1 => writer.print("op_exponentiate1", .{}),
            .op_exponentiate1_assign => writer.print("op_exponentiate1_assign", .{}),
            .op_exponentiate => writer.print("op_exponentiate", .{}),
            .op_exponentiate_assign => writer.print("op_exponentiate_assign", .{}),
            .op_divide => writer.print("op_divide", .{}),
            .op_divide_assign => writer.print("op_divide_assign", .{}),
            .op_integer_divide => writer.print("op_integer_divide", .{}),
            .op_integer_divide_assign => writer.print("op_integer_divide_assign", .{}),
            .op_modulus => writer.print("op_modulus", .{}),
            .op_modulus_assign => writer.print("op_modulus_assign", .{}),
            .op_remainder => writer.print("op_remainder", .{}),
            .op_remainder_assign => writer.print("op_remainder_assign", .{}),
            .op_nullify => writer.print("op_nullify", .{}),
            .op_nullish_or => writer.print("op_nullish_or", .{}),
            .op_nullish_or_assign => writer.print("op_nullish_or_assign", .{}),
            .op_not => writer.print("op_not", .{}),
            .op_not_not => writer.print("op_not_not", .{}),
            .op_not_equal => writer.print("op_not_equal", .{}),
            .op_declare_generic => writer.print("op_declare_generic", .{}),
            .op_declare_readonly => writer.print("op_declare_readonly", .{}),
            .op_declare_writable => writer.print("op_declare_writable", .{}),
            .op_declare_temporary => writer.print("op_declare_temporary", .{}),
            .op_comma => writer.print("op_comma", .{}),
            .op_logical_and => writer.print("op_logical_and", .{}),
            .op_logical_and_assign => writer.print("op_logical_and_assign", .{}),
            .op_logical_or => writer.print("op_logical_or", .{}),
            .op_logical_or_assign => writer.print("op_logical_or_assign", .{}),
            .op_bitwise_and => writer.print("op_bitwise_and", .{}),
            .op_bitwise_and_assign => writer.print("op_bitwise_and_assign", .{}),
            .op_bitwise_or => writer.print("op_bitwise_or", .{}),
            .op_bitwise_or_assign => writer.print("op_bitwise_or_assign", .{}),
            .op_bitwise_xor => writer.print("op_bitwise_xor", .{}),
            .op_bitwise_xor_assign => writer.print("op_bitwise_xor_assign", .{}),
            .op_bitwise_flip => writer.print("op_bitwise_flip", .{}),
            .op_bitshift_left => writer.print("op_bitshift_left", .{}),
            .op_bitshift_left_assign => writer.print("op_bitshift_left_assign", .{}),
            .op_bitshift_right => writer.print("op_bitshift_right", .{}),
            .op_bitshift_right_assign => writer.print("op_bitshift_right_assign", .{}),
            .op_lambda1 => writer.print("op_lambda1", .{}),
            .op_lambda2 => writer.print("op_lambda2", .{}),
            .op_lambda3 => writer.print("op_lambda3", .{}),
            .op_lambda4 => writer.print("op_lambda4", .{}),
            .op_lambda5 => writer.print("op_lambda5", .{}),
            .op_lambda6 => writer.print("op_lambda6", .{}),
            .op_lambda7 => writer.print("op_lambda7", .{}),
            .op_lambda8 => writer.print("op_lambda8", .{}),
            .op_indent => writer.print("op_indent", .{}),
            .op_access => writer.print("op_access", .{}),
            .op_readonly_member_access => writer.print("op_readonly_member_access", .{}),
            .op_writable_member_access => writer.print("op_writable_member_access", .{}),
            .op_temporary_member_access => writer.print("op_temporary_member_access", .{}),
            .op_wr_member_access => writer.print("op_wr_member_access", .{}),
            .op_rw_member_access => writer.print("op_rw_member_access", .{}),
            .op_wt_member_access => writer.print("op_wt_member_access", .{}),
            .op_tw_member_access => writer.print("op_tw_member_access", .{}),
            .op_rt_member_access => writer.print("op_rt_member_access", .{}),
            .op_tr_member_access => writer.print("op_tr_member_access", .{}),
            .op_rwt_member_access => writer.print("op_rwt_member_access", .{}),
            .op_wrt_member_access => writer.print("op_wrt_member_access", .{}),
            .op_rtw_member_access => writer.print("op_rtw_member_access", .{}),
            .op_wtr_member_access => writer.print("op_wtr_member_access", .{}),
            .op_trw_member_access => writer.print("op_trw_member_access", .{}),
            .op_twr_member_access => writer.print("op_twr_member_access", .{}),
        };
    }

    pub fn string(self: Self) SmallString {
        return switch (self) {
            .op_return => SmallString.noAlloc("return"),
            .op_new_generic => SmallString.noAlloc("~"),
            .op_increment => SmallString.noAlloc("++"),
            .op_decrement => SmallString.noAlloc("--"),
            .op_assign => SmallString.noAlloc("="),
            .op_equals => SmallString.noAlloc("=="),
            .op_less_than => SmallString.noAlloc("<"),
            .op_less_equal => SmallString.noAlloc("<="),
            .op_greater_than => SmallString.noAlloc(">"),
            .op_greater_equal => SmallString.noAlloc(">="),
            .op_plus => SmallString.noAlloc("+"),
            .op_plus_assign => SmallString.noAlloc("+="),
            .op_minus => SmallString.noAlloc("-"),
            .op_minus_assign => SmallString.noAlloc("-="),
            .op_multiply => SmallString.noAlloc("*"),
            .op_multiply_assign => SmallString.noAlloc("*="),
            .op_exponentiate1 => SmallString.noAlloc("**"),
            .op_exponentiate1_assign => SmallString.noAlloc("**="),
            .op_exponentiate => SmallString.noAlloc("^"),
            .op_exponentiate_assign => SmallString.noAlloc("^="),
            .op_divide => SmallString.noAlloc("/"),
            .op_divide_assign => SmallString.noAlloc("/="),
            .op_integer_divide => SmallString.noAlloc("//"),
            .op_integer_divide_assign => SmallString.noAlloc("//="),
            .op_modulus => SmallString.noAlloc("%"),
            .op_modulus_assign => SmallString.noAlloc("%="),
            .op_remainder => SmallString.noAlloc("%%"),
            .op_remainder_assign => SmallString.noAlloc("%%="),
            .op_nullify => SmallString.noAlloc("?"),
            .op_nullish_or => SmallString.noAlloc("??"),
            .op_nullish_or_assign => SmallString.noAlloc("??="),
            .op_not => SmallString.noAlloc("!"),
            .op_not_not => SmallString.noAlloc("!!"),
            .op_not_equal => SmallString.noAlloc("!="),
            .op_declare_generic => SmallString.noAlloc("`"),
            .op_declare_readonly => SmallString.noAlloc(":"),
            .op_declare_writable => SmallString.noAlloc(";"),
            .op_declare_temporary => SmallString.noAlloc("."),
            .op_comma => SmallString.noAlloc(","),
            .op_logical_and => SmallString.noAlloc("&&"),
            .op_logical_and_assign => SmallString.noAlloc("&&="),
            .op_logical_or => SmallString.noAlloc("||"),
            .op_logical_or_assign => SmallString.noAlloc("||="),
            .op_bitwise_and => SmallString.noAlloc("&"),
            .op_bitwise_and_assign => SmallString.noAlloc("&="),
            .op_bitwise_or => SmallString.noAlloc("|"),
            .op_bitwise_or_assign => SmallString.noAlloc("|="),
            .op_bitwise_xor => SmallString.noAlloc("><"),
            .op_bitwise_xor_assign => SmallString.noAlloc("><="),
            .op_bitwise_flip => SmallString.noAlloc("<>"),
            .op_bitshift_left => SmallString.noAlloc("<<"),
            .op_bitshift_left_assign => SmallString.noAlloc("<<="),
            .op_bitshift_right => SmallString.noAlloc(">>"),
            .op_bitshift_right_assign => SmallString.noAlloc(">>="),
            .op_lambda1 => SmallString.noAlloc("$"),
            .op_lambda2 => SmallString.noAlloc("$$"),
            .op_lambda3 => SmallString.noAlloc("$$$"),
            .op_lambda4 => SmallString.noAlloc("$$$$"),
            .op_lambda5 => SmallString.noAlloc("$$$$$"),
            .op_lambda6 => SmallString.noAlloc("$$$$$$"),
            .op_lambda7 => SmallString.noAlloc("$$$$$$$"),
            .op_lambda8 => SmallString.noAlloc("$$$$$$$$"),
            .op_indent => SmallString.noAlloc("\t"),
            .op_access => SmallString.noAlloc(" "),
            .op_readonly_member_access => SmallString.noAlloc("::"),
            .op_writable_member_access => SmallString.noAlloc(";;"),
            .op_temporary_member_access => SmallString.noAlloc(".."),
            .op_wr_member_access => SmallString.noAlloc(";:"),
            .op_rw_member_access => SmallString.noAlloc(":;"),
            .op_wt_member_access => SmallString.noAlloc(";."),
            .op_tw_member_access => SmallString.noAlloc(".;"),
            .op_rt_member_access => SmallString.noAlloc(":."),
            .op_tr_member_access => SmallString.noAlloc(".:"),
            .op_rwt_member_access => SmallString.noAlloc(":;."),
            .op_wrt_member_access => SmallString.noAlloc(";:."),
            .op_rtw_member_access => SmallString.noAlloc(":.;"),
            .op_wtr_member_access => SmallString.noAlloc(";.:"),
            .op_trw_member_access => SmallString.noAlloc(".:;"),
            .op_twr_member_access => SmallString.noAlloc(".;:"),
            .op_none => SmallString{},
        };
    }

    pub fn isPrefixable(self: Self) bool {
        return switch (self) {
            .op_return,
            .op_new_generic,
            .op_not,
            .op_not_not,
            .op_nullify,
            op_positive,
            .op_increment,
            op_negate,
            .op_decrement,
            .op_lambda1,
            .op_lambda2,
            .op_lambda3,
            .op_lambda4,
            .op_lambda5,
            .op_lambda6,
            .op_lambda7,
            .op_lambda8,
            .op_readonly_member_access,
            .op_writable_member_access,
            .op_temporary_member_access,
            .op_wr_member_access,
            .op_rw_member_access,
            .op_wt_member_access,
            .op_tw_member_access,
            .op_rt_member_access,
            .op_tr_member_access,
            .op_rwt_member_access,
            .op_wrt_member_access,
            .op_rtw_member_access,
            .op_wtr_member_access,
            .op_trw_member_access,
            .op_twr_member_access,
            => true,
            else => false,
        };
    }

    pub fn isPostfixable(self: Self) bool {
        return switch (self) {
            op_moot,
            op_cancel_if_null,
            .op_comma,
            .op_increment,
            .op_decrement,
            .op_declare_generic,
            .op_declare_readonly,
            .op_declare_writable,
            .op_declare_temporary,
            .op_wr_member_access,
            .op_rw_member_access,
            .op_wt_member_access,
            .op_tw_member_access,
            .op_rt_member_access,
            .op_tr_member_access,
            .op_rwt_member_access,
            .op_wrt_member_access,
            .op_rtw_member_access,
            .op_wtr_member_access,
            .op_trw_member_access,
            .op_twr_member_access,
            => true,
            else => false,
        };
    }

    pub fn isInfixable(self: Self) bool {
        return switch (self) {
            .op_assign,
            .op_equals,
            .op_less_than,
            .op_less_equal,
            .op_greater_than,
            .op_greater_equal,
            .op_plus,
            .op_plus_assign,
            .op_minus,
            .op_minus_assign,
            .op_multiply,
            .op_multiply_assign,
            .op_exponentiate1,
            .op_exponentiate1_assign,
            .op_exponentiate,
            .op_exponentiate_assign,
            .op_divide,
            .op_divide_assign,
            .op_integer_divide,
            .op_integer_divide_assign,
            .op_modulus,
            .op_modulus_assign,
            .op_remainder,
            .op_remainder_assign,
            .op_nullish_or,
            .op_nullish_or_assign,
            .op_not_equal,
            .op_declare_generic,
            .op_declare_readonly,
            .op_declare_writable,
            .op_declare_temporary,
            .op_comma,
            .op_indent,
            .op_access,
            .op_readonly_member_access,
            .op_writable_member_access,
            .op_temporary_member_access,
            .op_wr_member_access,
            .op_rw_member_access,
            .op_wt_member_access,
            .op_tw_member_access,
            .op_rt_member_access,
            .op_tr_member_access,
            .op_rwt_member_access,
            .op_wrt_member_access,
            .op_rtw_member_access,
            .op_wtr_member_access,
            .op_trw_member_access,
            .op_twr_member_access,
            .op_logical_and,
            .op_logical_and_assign,
            .op_logical_or,
            .op_logical_or_assign,
            .op_bitwise_and,
            .op_bitwise_and_assign,
            .op_bitwise_or,
            .op_bitwise_or_assign,
            .op_bitwise_xor,
            .op_bitwise_xor_assign,
            .op_bitwise_flip,
            .op_bitshift_left,
            .op_bitshift_left_assign,
            .op_bitshift_right,
            .op_bitshift_right_assign,
            => true,
            else => false,
        };
    }
    // TODO: we need a "parentheses affinity" for formatting.
    // e.g., does it look like `+ (whatever)` or `+(whatever)`?

    pub const op_positive: Self = .op_plus;
    pub const op_negate: Self = .op_minus;
    pub const op_negative: Self = .op_minus;
    pub const op_moot: Self = .op_not;
    pub const op_cancel_if_null: Self = .op_nullify;

    pub const Operation = OperatorOperation;
    const Self = @This();
};

const OperationType = enum {
    none,
    prefix,
    infix,
    postfix,

    pub fn printLine(self: Self, writer: anytype) !void {
        try self.print(writer);
        try writer.print("\n", .{});
    }

    pub fn print(self: Self, writer: anytype) !void {
        return switch (self) {
            .none => writer.print("Operation.Type.none", .{}),
            .prefix => writer.print("Operation.Type.prefix", .{}),
            .infix => writer.print("Operation.Type.infix", .{}),
            .postfix => writer.print("Operation.Type.postfix", .{}),
        };
    }

    const Self = @This();
};

const OperatorOperation = struct {
    operator: Operator = .op_none,
    type: Type = Type.none,

    pub fn printLine(self: Self, writer: anytype) !void {
        try self.print(writer);
        try writer.print("\n", .{});
    }

    pub fn print(self: Self, writer: anytype) !void {
        try writer.print("Operation{{ .operator = ", .{});
        try self.operator.print(writer);
        try writer.print(", .type = ", .{});
        try self.type.print(writer);
        try writer.print("}}", .{});
    }

    pub fn isPrefix(self: Self) bool {
        return self.type == Type.prefix;
    }
    pub fn isInfix(self: Self) bool {
        return self.type == Type.infix;
    }
    pub fn isPostfix(self: Self) bool {
        return self.type == Type.postfix;
    }

    /// Higher precedence means higher priority
    pub fn precedence(self: Self, compare: Compare) u8 {
        const rtl: u8 = @intFromEnum(compare);
        return switch (self.operator) {
            .op_none => 254,
            // TODO: decide if this should be higher than comma.
            // `return 3, 4` should be what?
            .op_return => 1,
            .op_new_generic => 250,
            .op_increment, .op_decrement => 220,
            .op_equals,
            .op_less_than,
            .op_less_equal,
            .op_greater_than,
            .op_greater_equal,
            .op_not_equal,
            => 160,
            .op_plus, .op_minus => if (self.isInfix()) 180 else (210 + rtl),
            .op_exponentiate1, .op_exponentiate => 220,
            .op_multiply,
            .op_divide,
            .op_integer_divide,
            .op_modulus,
            .op_remainder,
            => 190,
            .op_nullify => 230,
            // TODO: should this drop in priority???
            .op_nullish_or => 230,
            .op_not, .op_not_not => 210 + rtl,
            .op_comma => 10,
            .op_indent => 20,
            .op_logical_and => 170,
            .op_logical_or => 170,
            .op_bitwise_and, .op_bitwise_or => 180,
            .op_bitwise_xor => 170,
            .op_bitwise_flip => 210 + rtl,
            .op_bitshift_left, .op_bitshift_right => 200,
            .op_declare_generic,
            .op_declare_readonly,
            .op_declare_writable,
            .op_declare_temporary,
            => 130 + rtl,
            .op_assign,
            .op_plus_assign,
            .op_minus_assign,
            .op_multiply_assign,
            .op_exponentiate1_assign,
            .op_exponentiate_assign,
            .op_divide_assign,
            .op_integer_divide_assign,
            .op_modulus_assign,
            .op_remainder_assign,
            .op_nullish_or_assign,
            .op_logical_and_assign,
            .op_logical_or_assign,
            .op_bitwise_and_assign,
            .op_bitwise_or_assign,
            .op_bitwise_xor_assign,
            .op_bitshift_left_assign,
            .op_bitshift_right_assign,
            => 120 + rtl,
            .op_lambda1,
            .op_lambda2,
            .op_lambda3,
            .op_lambda4,
            .op_lambda5,
            .op_lambda6,
            .op_lambda7,
            .op_lambda8,
            => 250,
            .op_access,
            .op_readonly_member_access,
            .op_writable_member_access,
            .op_temporary_member_access,
            .op_wr_member_access,
            .op_rw_member_access,
            .op_wt_member_access,
            .op_tw_member_access,
            .op_rt_member_access,
            .op_tr_member_access,
            .op_rwt_member_access,
            .op_wrt_member_access,
            .op_rtw_member_access,
            .op_wtr_member_access,
            .op_trw_member_access,
            .op_twr_member_access,
            => 240,
        };
    }

    pub const Compare = enum {
        on_left,
        on_right,
    };
    pub const Type = OperationType;
    const Self = @This();
};

test "rewritten operator tokens" {
    try std.testing.expectEqual(Operator.op_declare_writable, Operator.init(";="));
    try std.testing.expectEqual(Operator.op_declare_readonly, Operator.init(":="));
}
